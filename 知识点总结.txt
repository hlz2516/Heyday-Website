1. 应用程序管道和中间件
    首先，要了解什么是应用程序管道，这是个抽象概念。首先用户的每个http请求流程都是线性的，对应到程序中就是一个
请求管道，在这个请求管道中我们可以配置各种各样的中间件，从而达到服务端可以针对不同用户做出不同的请求响应。
    而中间件，就是组装到应用程序管道中的处理请求和响应的组件。

本系统使用到的中间件以及执行顺序：
UseDeveloperExceptionPage(开发环境下)->UseStaticFiles->UseDefaultFiles->UseSession->UseRouting->UseAuthentication
->UseAuthorization->UseEndpoints

2. startup类的config和configservice方法是干什么的

configservice是配置各种服务的，即注册各种中间件，注册好了后才可以在config方法中加入中间件使用。所以configservice会在
config之前由Host类调用。
config方法通过将中间件组件添加到IApplicationBuilder实例（这个实例是托管创建的）来配置请求管道。

3. 依赖注入（控制反转的思想）
（最直观的感受，不用自己去new了）
何为依赖，一个类A需要另一个类B才能协调完成工作，那么就称A依赖于B
何为注入，把依赖的创建丢给其它人，自己只负责使用，其它人丢给你依赖的这个过程理解为注入
何为容器，容器就是管理依赖的一个东西，主要负责绑定服务与实例之间的关系，设置实例的生命周期，对实例进行管理。

讲到生命周期，这里详细讲下singleton,scope,transient三者的区别
经过测试，singleton一旦创建，在整个应用程序周期中都使用这一个实例
scope在每次请求时被创建，整个请求过程中都贯穿使用这个创建的服务
transient 服务在每次请求时被创建
总结：
singleton:不同的请求同一个实例
scope:同一个请求同一个实例
transient:每一次请求不同的实例

在asp.net core中依赖注入有几种方式
1. 通过构造函数注入
2. 在方法中通过在参数前加一个fromservice注解加入
3.在startup的config方法中通过参数注入
4. 在视图中通过@inject注入


4.identity core
这块深起来太深，就讲点浅显的东西
在本系统中注册了默认的identitycore中间件以及采用默认的cookie身份认证的方案,通过在controller中注入identity core三大对象usermanager,signinmanager,rolemanager来完成登录注册，修改密码，然后
不同的用户可以看到不同的菜单栏,就是说不同权限的用户，能使用的功能也会有所差异。

5.设计模式
   单例模式
   特点：只能生成一个实例，由该类自己创建，向外部提供一个全局访问点
   优点：只有一个实例，减少了内存的开销
   缺点：不易于扩展
	懒汉式（只有调用时才创建）
     class Singleton
    {
        private static Singleton singleton;
        private Singleton()
        {

        }
        public static Singleton GetInstance()
        {
            if (singleton == null)
                singleton = new Singleton();
            return singleton;
        }
    }

	饿汉式（程序加载时就创建）
     class Singleton
    {
        private static Singleton singleton = new Singleton();
        private Singleton()
        {

        }
        public static Singleton GetInstance()
        {
            return singleton;
        }
    }

	工厂方法模式
	结构：一个抽象工厂（接口），多个具体工厂（对抽象工厂的具体实现），
	      一个抽象产品（接口），多个具体产品（对抽象产品的具体实现）。
	
	abstract class Factory{
    		public abstract Product Manufacture();
	}

	abstract class Product{
    		public abstract void Show();
	}
        //具体产品A类
	class  ProductA extends  Product{
    		@Override
    		public void Show() {
        		System.out.println("生产出了产品A");
    		}
	}
 
	//具体产品B类
	class  ProductB extends  Product{
 
    	@Override
    	public void Show() {
        	System.out.println("生产出了产品B");
    		}
	}
	//工厂A类 - 生产A类产品
	class  FactoryA extends Factory{
	    @Override
	    public Product Manufacture() {
	        return new ProductA();
	    }
	}
 
	//工厂B类 - 生产B类产品
	class  FactoryB extends Factory{
	    @Override
	    public Product Manufacture() {
	        return new ProductB();
	    }
	}

	优点：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
	缺点：添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，
	在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；

